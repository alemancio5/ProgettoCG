#version 450layout(location = 0) in vec2 fragUV;layout(location = 1) in vec3 fragPos;layout(location = 2) in vec3 fragNorm;layout(set = 0, binding = 1) uniform sampler2D text;layout(binding = 2) uniform LightsDiffusion {	vec3 viewPos;	vec3 lightPos;	vec4 lightColor;					// Possibile parametro da modificare per fare la luce verde quando prendeo l'item	vec4 lightStatus;	float ambientStrength;	float specularStrength;	float shininess;	float cosIn;	float cosOut;} ubo;layout(location = 0) out vec4 outColor;void main() {	// INIZIALIZZAZIONI UTILI	// Normalizzazione della normale	vec3 norm = normalize(fragNorm);	// Eye direction	vec3 viewDir = normalize(ubo.viewPos - fragPos);	// Sample the texture using UV coordinates	vec3 texColor = texture(text, fragUV).rgb;	// Calcolo del vettore luce	vec3 lightDir = normalize(ubo.lightPos - fragPos);	// COMPONENTI DI LUCE	// Componente diffusa	float diffuse = max(dot(norm, lightDir), 0.0);	// Calcolo del riflesso speculare	float specular = ubo.specularStrength * pow(max(dot(viewDir, reflect(-lightDir, norm)), 0.0), ubo.shininess);	// Componente ambiente	float ambient = ubo.ambientStrength;	// LUCE A PUNTO	vec3 pointLight = ubo.lightColor.rgb * pow((ubo.lightColor.a / length(ubo.lightPos - fragPos)), 2.0);	vec3 result = (ambient + diffuse + specular) * pointLight * texColor * ubo.lightStatus.y;	// LUCE SPOT	vec3 spotLight = ubo.lightColor.rgb *						pow((ubo.lightColor.a / length(ubo.lightPos - fragPos)), 2.0) *						clamp( ( dot(normalize(ubo.lightPos - fragPos), lightDir) - ubo.cosOut ) / (ubo.cosIn - ubo.cosOut), 0.0, 1.0 );	result += (ambient + diffuse + specular) * spotLight * texColor * ubo.lightStatus.z;	// Final light	vec3 finalColor = texColor + result;	outColor = vec4(finalColor, 1.0);}