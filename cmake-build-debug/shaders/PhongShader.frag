#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragTexCoord;layout(location = 0) out vec4 outColor;layout(set = 0, binding = 1) uniform sampler2D texSampler;layout(set = 0, binding = 2) uniform ParamUniformBufferObject {	vec3 lightDir;	vec3 lightPos;	vec4 lightColor;	float cosIn;	float cosOut;	vec3 eyePos;	vec4 eyeDir;	float lightOn;} pubo;vec3 spot_light_dir(vec3 pos) {	// Spot light - direction vector	// Direction of the light in <gubo.lightDir[i]>	// Position of the light in <gubo.lightPos[i]>	return normalize(pubo.lightPos - pos);}vec3 spot_light_color(vec3 pos) {	// Spot light - color	// Color of the light in <gubo.lightColor[i].rgb>	// Scaling factor g in <gubo.lightColor[i].a>	// Decay power beta: constant and fixed to 2.0	// Position of the light in <gubo.lightPos[i]>	// Direction of the light in <gubo.lightDir[i]>	// Cosine of half of the inner angle in <gubo.cosIn>	// Cosine of half of the outer angle in <gubo.cosOut>	return pubo.lightColor.rgb *	pow((pubo.lightColor.a / length(pubo.lightPos - pos)), 2.0) *	clamp( ( dot(normalize(pubo.lightPos - pos), pubo.lightDir) - pubo.cosOut ) / (pubo.cosIn - pubo.cosOut), 0.0, 1.0 );}vec3 BRDF(vec3 Albedo, vec3 Norm, vec3 EyeDir, vec3 LD) {	// Compute the BRDF, with a given color <Albedo>, in a given position characterized bu a given normal vector <Norm>,	// for a light direct according to <LD>, and viewed from a direction <EyeDir>	vec3 Diffuse;	vec3 Specular;	Diffuse = Albedo * max(dot(Norm, LD), 0.0f);	Specular = vec3(pow(max(dot(EyeDir, -reflect(LD, Norm)),0.0f), 160.0f));	return Diffuse + Specular;}void main() {	// Approximate the rendering equation for the current pixel (fragment), and return	// the solution in global variable <outColor>	vec3 Norm = normalize(fragNorm);	vec3 EyeDir = normalize(pubo.eyePos - fragPos);	vec3 Albedo = texture(texSampler, fragTexCoord).rgb;	vec3 LD;	// light direction	vec3 LC;	// light color	vec3 RendEqSol = vec3(0);	// Fift light	LD = spot_light_dir(fragPos);	LC = spot_light_color(fragPos);	RendEqSol = BRDF(Albedo, Norm, EyeDir, LD) * LC         * pubo.lightOn;	// Indirect illumination simulation	// A special type of non-uniform ambient color, invented for this course	const vec3 cxp = vec3(1.0,0.5,0.5) * 0.2;	const vec3 cxn = vec3(0.9,0.6,0.4) * 0.2;	const vec3 cyp = vec3(0.3,1.0,1.0) * 0.2;	const vec3 cyn = vec3(0.5,0.5,0.5) * 0.2;	const vec3 czp = vec3(0.8,0.2,0.4) * 0.2;	const vec3 czn = vec3(0.3,0.6,0.7) * 0.2;	vec3 Ambient =((Norm.x > 0 ? cxp : cxn) * (Norm.x * Norm.x) +	(Norm.y > 0 ? cyp : cyn) * (Norm.y * Norm.y) +	(Norm.z > 0 ? czp : czn) * (Norm.z * Norm.z)) * Albedo;	RendEqSol += Ambient         * pubo.lightOn;	// Output color	outColor = vec4(RendEqSol, 1.0f);}